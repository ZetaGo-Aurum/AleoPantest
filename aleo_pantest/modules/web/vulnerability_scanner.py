"""Vulnerability Scanner Tool"""
import requests
from typing import Dict, List, Any

from ...core.base_tool import BaseTool, ToolMetadata, ToolCategory
from ...core.logger import logger


class VulnerabilityScanner(BaseTool):
    """Web vulnerability scanner untuk common vulnerabilities"""
    
    def __init__(self):
        metadata = ToolMetadata(
            name="Vulnerability Scanner",
            category=ToolCategory.WEB,
            version="1.0.0",
            author="AleoPantest",
            description="Web vulnerability scanner untuk deteksi common web vulnerabilities",
            usage="scanner = VulnerabilityScanner(); scanner.run(url='http://target.com')",
            requirements=["requests"],
            tags=["web", "scanner", "vulnerability", "testing"]
        )
        super().__init__(metadata)
    
    def validate_input(self, url: str, **kwargs) -> bool:
        """Validate input"""
        if not url:
            self.add_error("URL tidak boleh kosong")
            return False
        if not url.startswith(('http://', 'https://')):
            self.add_error("Invalid URL format")
            return False
        return True
    
    def check_headers(self, url: str) -> Dict[str, Any]:
        """Check security headers"""
        result = {
            'vulnerabilities': [],
            'warnings': [],
            'headers': {}
        }
        
        try:
            response = requests.get(url, timeout=10)
            headers = response.headers
            result['headers'] = dict(headers)
            
            # Security headers to check
            security_headers = {
                'Strict-Transport-Security': 'HSTS',
                'X-Frame-Options': 'Clickjacking Protection',
                'X-Content-Type-Options': 'MIME Sniffing',
                'Content-Security-Policy': 'CSP',
                'X-XSS-Protection': 'XSS Protection',
            }
            
            for header, name in security_headers.items():
                if header not in headers:
                    result['vulnerabilities'].append(f"Missing {name} header")
                    logger.warning(f"Missing security header: {name}")
            
            # Check for dangerous headers
            if 'Server' in headers:
                result['warnings'].append(f"Server header exposed: {headers['Server']}")
            
            # Check for outdated framework versions
            dangerous_patterns = [
                ('X-Powered-By', 'Technology stack exposed'),
                ('X-AspNet-Version', 'ASP.NET version exposed'),
                ('X-Runtime', 'Runtime information exposed'),
            ]
            
            for header, msg in dangerous_patterns:
                if header in headers:
                    result['vulnerabilities'].append(msg)
        
        except Exception as e:
            logger.error(f"Error checking headers: {e}")
        
        return result
    
    def check_common_paths(self, url: str) -> Dict[str, List[str]]:
        """Check for common paths/files"""
        result = {'found': [], 'not_found': []}
        
        common_paths = [
            '/robots.txt',
            '/sitemap.xml',
            '/admin',
            '/administrator',
            '/.git',
            '/.env',
            '/config.php',
            '/backup',
            '/.well-known/security.txt',
            '/wp-admin',
            '/phpmyadmin',
        ]
        
        for path in common_paths:
            try:
                response = requests.get(url + path, timeout=5, allow_redirects=False)
                if response.status_code < 400:
                    result['found'].append(path)
                    logger.warning(f"Found: {path}")
                else:
                    result['not_found'].append(path)
            except:
                result['not_found'].append(path)
        
        return result
    
    def run(self, url: str, timeout: int = 10, **kwargs):
        """Scan URL for vulnerabilities"""
        if not self.validate_input(url, **kwargs):
            return
        
        self.is_running = True
        self.clear_results()
        
        try:
            logger.info(f"Scanning {url} for vulnerabilities")
            
            result = {
                'url': url,
                'vulnerabilities_found': 0,
                'security_headers': self.check_headers(url),
                'common_paths': self.check_common_paths(url),
            }
            
            # Count vulnerabilities
            result['vulnerabilities_found'] = (
                len(result['security_headers']['vulnerabilities']) +
                len(result['security_headers']['warnings']) +
                len(result['common_paths']['found'])
            )
            
            self.add_result(result)
            logger.info(f"Vulnerability scan completed. Found {result['vulnerabilities_found']} issues")
            return result
            
        except Exception as e:
            self.add_error(f"Vulnerability scan failed: {e}")
        finally:
            self.is_running = False
